defmodule DiceMagickWeb.CharacterLive.Show do
  @moduledoc false

  use Phoenix.LiveView
  require Logger

  alias DiceMagick.{Characters, Discord, Rolls}
  alias Characters.Character
  alias DiceMagickWeb.CharacterLive.State

  import State

  @throttle_time 1000

  @impl true
  def mount(%{"id" => character_id}, _session, socket) do
    character = Characters.get_character!(character_id, preload: :roll_results)
    state = Characters.Worker.state(character_id)
    {favorites, rolls} = favorites(state.rolls)

    synced_at =
      state = %State{
        character: character,
        synced_at:
          case state.synced_at do
            nil -> ""
            datetime -> format_synced_at(datetime)
          end,
        results: trim_results(character.roll_results),
        selected: nil,
        rolls: rolls,
        pinned_rolls: favorites,
        tags: state.tags
      }

    {:ok, assign_state(socket, state)}
  end

  @impl true
  def render(assigns) do
    Phoenix.View.render(DiceMagickWeb.CharacterView, "show.html", assigns)
  end

  ## Callbacks

  @impl true
  def handle_event("sync", _params, %{assigns: %{character: character}} = socket) do
    %{rolls: rolls, synced_at: synced_at} = Characters.Worker.update_sync(character.id)
    Process.send_after(self(), :unblock, @throttle_time)

    state = [rolls: rolls, synced_at: format_synced_at(synced_at), allow_sync: false]

    {:noreply, assign(socket, state)}
  end

  @impl true
  def handle_event("roll", %{"name" => roll_name, "type" => "advantage"}, socket) do
    state = State.from_socket()
    result = roll(roll_name, state, times: 2, compare_fn: &Kernel.>/2)
    send_message(state.character, result, "advantage")

    {:noreply, assign(socket, :results, [result] ++ state.result)}
  end

  @impl true
  def handle_event("roll", %{"name" => roll_name, "type" => "disadvantage"}, socket) do
    state = State.from_socket()
    result = roll(roll_name, state, times: 2, compare_fn: &Kernel.</2)
    send_message(state.character, result, "disadvantage")

    {:noreply, assign(socket, :results, [result] ++ state.result)}
  end

  @impl true
  def handle_event("roll", %{"name" => roll_name}, socket) do
    state = State.from_socket()
    result = roll(roll_name, state)
    send_message(state.character, result)

    {:noreply, assign(socket, assigns)}
  end

  @impl true
  def handle_event("apply-tag", %{"tag" => tag}, socket) do
    %{assigns: %{rolls: rolls, pinned_rolls: pinned_rolls, active_tags: active_tags}} = socket

    active_tags =
      case Enum.member?(active_tags, tag) do
        true -> Enum.filter(active_tags, &(&1 != tag))
        false -> active_tags ++ [tag]
      end

    all_rolls = pinned_rolls ++ rolls

    pinned_rolls =
      case Enum.count(active_tags) do
        0 ->
          {favorites, _} = favorites(all_rolls)
          favorites

        _ ->
          Enum.filter(all_rolls, fn roll ->
            Enum.any?(roll.tags, &Enum.member?(active_tags, &1))
          end)
      end
      |> Enum.sort_by(&String.first(&1.name))

    rolls = Enum.filter(all_rolls, fn roll -> !Enum.member?(pinned_rolls, roll) end)

    {:noreply,
     assign(socket, %{active_tags: active_tags, rolls: rolls, pinned_rolls: pinned_rolls})}
  end

  @impl true
  def handle_event("select", %{"name" => name, "expression" => expression}, socket) do
    selected =
      socket.assigns.character
      |> Rolls.get_roll_stats(name)
      |> Map.put(:name, name)
      |> Map.put(:expression, expression)

    {:noreply, assign(socket, %{selected: selected})}
  end

  @impl true
  def handle_event("deselect", _deselect, socket) do
    {:noreply, assign(socket, %{selected: nil})}
  end

  @impl true
  def handle_info(:unblock, socket), do: {:noreply, assign(socket, allow_sync: true)}

  @impl true
  def handle_info(:remove_highlight, socket) do
    {:noreply, assign(socket, last_highlighted: false)}
  end

  ## Helpers

  @spec favorites([map]) :: {[map], [map]}
  def favorites(rolls) do
    rolls
    |> Enum.sort_by(&String.first(&1.name))
    |> Enum.reduce({[], []}, fn cur, {favorites, rest} ->
      case cur.favorite do
        true -> {favorites ++ [cur], rest ++ [cur]}
        false -> {favorites, rest ++ [cur]}
      end
    end)
  end

  @spec format_synced_at(DateTime.t()) :: String.t()
  def format_synced_at(dt) do
    case Timex.Format.DateTime.Formatters.Relative.format!(dt, "{relative}") do
      "now" -> "Just now"
      str -> str
    end
  end

  @spec trim_results([Rolls.Result.t()]) :: [Rolls.Result.t()]
  def trim_results([]), do: []

  def trim_results(results) do
    results
    |> Enum.chunk_every(12)
    |> List.first()
  end

  @type roll_opts() :: [times: integer(), variant: String.t()]

  @spec roll(State.t(), String.t(), roll_opts()) :: {Result.t(), [integer()]}
  def roll(%State{character: character, rolls: rolls}, name, opts \\ []) do
    times = Keyword.get(opts, :times, 1)
    variant = Keyword.get(opts, :variant, "")

    roll = get_roll_by_name!(rolls, name)

    results =
      Enum.map(1..times, fn _ ->
        roll
        |> Map.put(character_id: character.id)
        |> Rolls.generate_result()
        |> Map.put(:name, name)
      end)

    {result, result.faces}
  end

  @spec roll(State.t(), String.t(), function()) :: {Result.t(), [integer()]}
  def roll(%State{character: character, rolls: rolls}, name, compare_fun) do
    [roll] = Enum.filter(rolls, &(&1.name == name))

    %Rolls.Result{faces: [first_face]} = first_result = roll(roll_name, state)
    second_result = roll(roll_name, state)

    result =
      if compare_fn.(first_result.total, second_result.total),
        do: first_result,
        else: second_result

    {result, [first_result.faces, face2]}
  end

  defp get_roll_by_name!(rolls, name) do
    case Enum.find(rolls, &(&1.name == name)) do
      nil -> raise ~s(Could not find roll named "#{name}")
      roll -> roll
    end
  end

  @spec roll_twice(State.t(), String.t(), function()) :: {Result.t(), [integer()]}
  def roll_twice(%State{} = state, roll_name, compare_fn) do
  end

  @spec send_message(Character.t(), Rolls.Result.t(), variant: String.t()) :: :ok
  def send_message(%Character{} = character, %Rolls.Result{} = result, opts \\ []) do
    variant =
      case opts[:variant] do
        "advantage" -> " with **advantage**"
        "disadvantage" -> " with **disadvantage**"
        _ -> ""
      end

    message = """
    **#{character.name}** rolls _#{result.name}_  (`#{result.expression}`)#{variant}â€¦
    :game_die: Result: **#{result.total}** (`[#{Enum.join(result.faces, ", ")}]`)
    """

    Discord.send_message(character.discord_channel_id, message)
    Process.send_after(self(), :remove_highlight, 2000)
  end
end
